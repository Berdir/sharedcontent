<?php

/*
 * @file
 * Tests for Shared Content Server
 */

class SharedContentServerTestCase extends SharedcontentBaseTestCase {

  protected $profile = 'testing';

  protected $entity_id = 1;

  /**
   * Implements getInfo().
   */
  static function getInfo() {
    return array(
      'name' => 'Server tests',
      'description' => 'Test for server features',
      'group' => 'Shared Content',
    );
  }

  /**
   * Overrides DrupalWebTestCase::setUp()
   */
  function setUp() {
    // Given a Drupal installation with installed sharedcontent server
    $dependencies = array(
      'sharedcontent_server_feature',
      'sharedcontent_template_server_rules',
      'taxonomy',
      'file',
    );
    $permissions = array();
    $permissions['editor'] = array(
      'administer nodes',
    );
    $permissions['admin'] = array(
      'administer views',
      'administer services',
      'administer site configuration',
      'administer sharedcontent',
    );
    $permissions['client'] = array(
      'access endpoint restricted',
    );
    parent::setUp($dependencies, $permissions);
    variable_set('sharedcontent_indexed_entities', array(
      'node' => array(
        'article' => TRUE,
        'page' => TRUE,
      ),
      'taxonomy_vocabulary' => array(
        'taxonomy_vocabulary' => TRUE,
      ),
      'file' => array(
        'file' => 1,
      ),
      'user' => array(
        'user' => 1,
      ),
    ));
  }

  /**
   * Test if the index is built correctly for core entities.
   */
  function testIndexCreation() {
    // When I create a new node
    $node = $this->drupalCreateNode();

    // Then I should have an index record in the sc index
    $index = sharedcontent_index_load_by_entity_id($node->nid, 'node');
    $this->assertEqual($index->title, $node->title);
    $this->assertEqual($index->entity_id, $node->nid);
    $this->assertEqual($index->entity_type, 'node');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_VISIBLE);
    $this->assertEqual($index->entity_created, $node->created);
    $this->assertEqual($index->entity_changed, $node->changed);
    $this->assertEqual($index->created, REQUEST_TIME);
    $this->assertEqual($index->changed, REQUEST_TIME);

    // When I get the index record for created node
    $index = sharedcontent_index_load_by_entity_id($node->nid, 'node');

    // Then I should have a existing record
    $this->assertFalse($index->id == NULL);

    // When I delete the node
    node_delete($node->nid);

    // Then the index record should have status disabled.
    $index = sharedcontent_index_load_by_entity_id($node->nid, 'node');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);

    // When I create a new vocabulary
    $vocabulary = $this->createVocabulary();

    // Then I should have an index record matching the vocabulary
    $index = sharedcontent_index_load_by_entity_id($vocabulary->vid, 'taxonomy_vocabulary');
    $this->assertEqual($index->title, $vocabulary->name);
    $this->assertEqual($index->entity_id, $vocabulary->vid);
    $this->assertEqual($index->entity_type, 'taxonomy_vocabulary');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);
    $this->assertEqual($index->entity_created, REQUEST_TIME);
    $this->assertEqual($index->entity_changed, REQUEST_TIME);
    $this->assertEqual($index->created, REQUEST_TIME);
    $this->assertEqual($index->changed, REQUEST_TIME);

    // Given the terms for the created vocabulary are indexed
    $indexed = variable_get('sharedcontent_indexed_entities', array());
    $indexed['taxonomy_term'][$vocabulary->machine_name] = TRUE;
    variable_set('sharedcontent_indexed_entities', $indexed);

    // When I create a new term
    $term = $this->createTerm($vocabulary);

    // Then I should have an index record matching the term
    $index = sharedcontent_index_load_by_entity_id( $term->tid, 'taxonomy_term');
    $this->assertEqual($index->title, $term->name);
    $this->assertEqual($index->entity_id, $term->tid);
    $this->assertEqual($index->entity_type, 'taxonomy_term');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_VISIBLE);
    $this->assertEqual($index->entity_created, REQUEST_TIME);
    $this->assertEqual($index->entity_changed, REQUEST_TIME);
    $this->assertEqual($index->created, REQUEST_TIME);
    $this->assertEqual($index->changed, REQUEST_TIME);

    // When I delete the therm
    taxonomy_term_delete($term->tid);

    // Then the index record should have status disabled.
    $index = sharedcontent_index_load_by_entity_id( $term->tid, 'taxonomy_term');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);

    // When I delete the vocabulary
    taxonomy_vocabulary_delete($vocabulary->vid);

    // Then the index record should have status disabled.
    $index = sharedcontent_index_load_by_entity_id($vocabulary->vid, 'taxonomy_vocabulary');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);

    // When I create a user
    $account = $this->drupalCreateUser();

    // Then I should have an index record for the user
    $index = sharedcontent_index_load_by_entity_id( $account->uid, 'user');
    $this->assertEqual($index->title, $account->name);
    $this->assertEqual($index->entity_id, $account->uid);
    $this->assertEqual($index->entity_type, 'user');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_VISIBLE);
    $this->assertEqual($index->entity_created, $account->created);
    $this->assertEqual($index->entity_changed, $index->entity_created);
    $this->assertEqual($index->created, REQUEST_TIME);
    $this->assertEqual($index->changed, REQUEST_TIME);

    // When I delete the user
    entity_delete('user', $account->uid);

    // Then the index record should have status disabled.
    $index = sharedcontent_index_load_by_entity_id($account->uid, 'user');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);

    // When I create a file
    $file = current($this->drupalGetTestFiles('text'));
    entity_save('file', $file);

    // Then I should have an index record for the file
    $index = sharedcontent_index_load_by_entity_id( $file->fid, 'file');
    $this->assertEqual($index->title, $file->filename);
    $this->assertEqual($index->entity_id, $file->fid);
    $this->assertEqual($index->entity_type, 'file');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_VISIBLE);
    $this->assertEqual($index->entity_created, $file->timestamp);
    $this->assertEqual($index->entity_changed, $file->timestamp);
    $this->assertEqual($index->created, REQUEST_TIME);
    $this->assertEqual($index->changed, REQUEST_TIME);

    // When I delete the file
    entity_delete('file', $file->fid);

    // Then the index record should have status disabled.
    $index = sharedcontent_index_load_by_entity_id($file->fid, 'file');
    $this->assertEqual($index->status, SHAREDCONTENT_INDEX_STATUS_UNREACHABLE);
  }

  /**
   * Test if the keywords are built correctly.
   */
  function testKeywordBuilding() {

    // Given a vocabulary and a few terms
    $this->vocabulary = $this->createVocabulary();
    $terms = array();
    for ($i = 0; $i < 5; $i++) {
      $terms[$i] = $this->createTerm($this->vocabulary);
    }

    // And a content type with a corresponding taxonomy reference field
    $this->field_name = drupal_strtolower($this->randomName());
    $this->field = array(
      'field_name' => $this->field_name,
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => '0',
          ),
        ),
      ),
    );
    field_create_field($this->field);
    $this->instance = array(
      'field_name' => $this->field_name,
      'entity_type' => 'node',
      'bundle' => 'page',
      'widget' => array(
        'type' => 'options_select',
      ),
      'display' => array(
        'full' => array(
          'type' => 'taxonomy_term_reference_link',
        ),
      ),
    );
    field_create_instance($this->instance);


    // When I log in as administrator
    $this->loginAsEditor();


    // And I create a new node with a taxonomy term
    $node = $this->drupalCreateNode(array(
      $this->field_name => array(
        LANGUAGE_NONE => array(
          array(
            'tid' => $terms[0]->tid,
          )
        ),
      ),
    ));

    // Then the keywords should be empty
    $index = entity_load('sharedcontent_index', FALSE, array('entity_id' => $node->nid));
    $index = array_shift($index);
    $this->assertEqual('', $index->keywords);

    // Given a taxonomy term field enabled for keyword building
    variable_set('sharedcontent_keyword_fields', array('node' => array($node->type => array($this->field_name => $this->field_name))));

    // And I create a new node with a taxonomy term
    $node = $this->drupalCreateNode(array(
      $this->field_name => array(
        LANGUAGE_NONE => array(
          array(
            'tid' => $terms[0]->tid,
          )
        ),
      ),
    ));

    // Then the keywords should match the term
    $index = sharedcontent_index_load_by_entity_id($node->nid);
    $this->assertEqual($terms[0]->name, $index->keywords);

    // And I create a new node with multiple taxonomy terms
    $node = $this->drupalCreateNode(array(
      $this->field_name => array(
        LANGUAGE_NONE => array(
          array(
            'tid' => $terms[0]->tid,
          ),
          array(
            'tid' => $terms[1]->tid,
          ),
          array(
            'tid' => $terms[2]->tid,
          ),
          array(
            'tid' => $terms[3]->tid,
          ),
          array(
            'tid' => $terms[4]->tid,
          ),
        ),
      ),
    ));

    // Then I the keywords should match the title and the term
    $index = entity_load('sharedcontent_index', FALSE, array('entity_id' => $node->nid));
    $index = array_shift($index);
    $expectation = array(
      $terms[0]->name,
      $terms[1]->name,
      $terms[2]->name,
      $terms[3]->name,
      $terms[4]->name,
    );
    $this->assertEqual(implode(' ', $expectation), $index->keywords);
  }

  /**
   * Test if the index is exposed correctly.
   */
  function testIndexService() {
    // Given a sharedcontent_index with five records.
    $nodes = array();
    $nodes[] = $this->drupalCreateNode();
    $nodes[] = $this->drupalCreateNode();
    $nodes[] = $this->drupalCreateNode();
    $nodes[] = $this->drupalCreateNode();
    $nodes[] = $this->drupalCreateNode();

    // And three records have an older changed and created value.
    db_update('sharedcontent_index')
      ->fields(array(
        'created' => REQUEST_TIME - 3600,
        'entity_created' => REQUEST_TIME - 3600,
        'changed' => REQUEST_TIME - 1800,
        'entity_changed' => REQUEST_TIME - 1800,
      ))
      ->condition('entity_id', 3, '>=')
      ->execute();

    // When I login as a client
    $this->loginAsClient();

    // And access the index resource
    $result = json_decode($this->drupalGet('sharedcontent/index.json'));

    // Then I should have five index records
    $this->assertEqual(count($nodes), count($result));

    $record = $result[0];
    $node = $nodes[0];
    $controller = entity_get_controller('sharedcontent_index');
    $this->assertTrue($controller->uuidIsValid($record->uuid));
    $this->assertEqual($record->entity_id, $node->nid);
    $this->assertEqual($record->entity_type, 'node');
    $this->assertEqual($record->entity_bundle, $node->type);
    $this->assertEqual($record->title, $node->title);
    $this->assertTrue(isset($record->keywords));
    $this->assertTrue(isset($record->tags));
    $this->assertEqual($record->status, SHAREDCONTENT_INDEX_STATUS_VISIBLE);
    $this->assertFalse(empty($record->url));
    $this->assertEqual($record->entity_created, $node->created);
    $this->assertEqual($record->entity_changed, $node->changed);
    $this->assertTrue(empty($record->created));
    $this->assertTrue(empty($record->changed));
    $this->assertTrue(isset($record->parent_uuid) || is_null($record->parent_uuid));


    // When I access the index resource with an offset query
    $result = json_decode($this->drupalGet('sharedcontent/index.json', array(
      'query' => array('offset' => 2),
    )));

    // Then I should have 3 index records
    $this->assertEqual(3, count($result));

    // And the index records belongs to the last tree nodes created
    $this->assertEqual($nodes[2]->nid, $result[0]->entity_id);
    $this->assertEqual($nodes[3]->nid, $result[1]->entity_id);
    $this->assertEqual($nodes[4]->nid, $result[2]->entity_id);

    // When I access the index resource with a limit query
    $result = json_decode($this->drupalGet('sharedcontent/index.json', array(
      'query' => array('limit' => 2),
    )));

    // Then I should have 2 index records
    $this->assertEqual(2, count($result));

    // And the index records belongs to the first two created nodes
    $this->assertEqual($nodes[0]->nid, $result[0]->entity_id);
    $this->assertEqual($nodes[1]->nid, $result[1]->entity_id);

    // When I access the index resource with a changed query
    $result = json_decode($this->drupalGet('sharedcontent/index.json', array(
      'query' => array('changed' => format_date(REQUEST_TIME - 1799, 'custom', 'c')),
    )));

    // Then I should have 2 index records
    $this->assertEqual(2, count($result));

    // And the index records belongs to the nodes with the none altered dates
    $this->assertEqual($nodes[0]->nid, $result[0]->entity_id);
    $this->assertEqual($nodes[1]->nid, $result[1]->entity_id);

    // Given an index record with a reason other than 'default'
    $term = $this->createTerm(taxonomy_vocabulary_machine_name_load('sharedcontent_reason'));
    $index = sharedcontent_index_load(1);
    $index->field_sharedcontent_reason = array(
      LANGUAGE_NONE => array(
        0 => array('tid' => $term->tid),
      ),
    );
    $index->save();

    // And the user I am currently logged in has the same reason assigned
    $this->user_client->field_sharedcontent_reason = array(
      LANGUAGE_NONE => array(
        0 => array('tid' => $term->tid),
      ),
    );
    entity_save('user', $this->user_client);

    // And reason checking is enabled
    variable_set('sharedcontent_check_reason', TRUE);

    // When I access the index resource
    $result = json_decode($this->drupalGet('sharedcontent/index.json'));

    // Then I should have one index record
    $this->assertEqual(1, count($result));

    // And the index records matches the one with the non default reason
    $this->assertEqual($index->entity_id, $result[0]->entity_id);
  }

  /**
   * Tests the index counting thought the service api.
   */
  public function testIndexCount() {
    // Given there are 101 records with increasing changed dates.
    $entity_id = 1;
    $count = 101;

    // Using a deterministic time for otherwise comparison will lead to
    // unexpected  results.
    $request_time = date('c', REQUEST_TIME);

    $date = new DateTime($request_time);
    $one_day = new DateInterval('P1D');
    while ($count > 0) {
      $date->sub($one_day);
      $index = entity_create('sharedcontent_index', array(
        'title' => $this->randomName(),
        'entity_id' => $entity_id,
        'entity_type' => 'node',
        'url' => url('node/' . $entity_id, array('absolute' => TRUE)),
        'created' => $date->getTimestamp(),
      ));
      $index->save();
      $count--;
    }
    // The changed date is updated on each save so we need to set it directly
    // in the database.
    db_update('sharedcontent_index')
      ->expression('changed', 'created')
      ->execute();

    // Given I am logged in as a client
    $this->loginAsClient();

    // When I do a count request to the index with changed date of current date.
    // Then the result should be zero.
    $date = new DateTime($request_time);
    $this->assertEqual(0, $this->serviceCountRequest($date->format('c')));

    // When I do a count request to the index with changed date minus one day.
    // Then the result should be 1.
    $date->sub($one_day);
    $this->assertEqual(1, $this->serviceCountRequest($date->format('c')));

    // When I do a count request to the index with changed date minus 100 days.
    // Then the result should be 100.
    $date->sub(new DateInterval('P99D'));
    $this->assertEqual(100, $this->serviceCountRequest($date->format('c')));

    // When I do a count request to the index with changed date minus 101 days.
    // Then the result should be 101.
    $date->sub($one_day);
    $this->assertEqual(101, $this->serviceCountRequest($date->format('c')));

    // When I do a count request to the index without a changed date.
    // Then the result should be 101.
    $this->assertEqual(101, $this->serviceCountRequest());
  }

  /**
   * Counts the index records through service call.
   *
   * @param $changed
   *   The changed dated used in the query.
   *
   * @return int
   *  The index count.
   */
  private function serviceCountRequest($changed = '') {
    $options = array('absolute' => TRUE);
    if (!empty($changed)) {
      $options['query'] = array( 'changed' => $changed);
    }
    $count = drupal_json_decode($this->curlExec(array(
      CURLOPT_URL => url("sharedcontent/index/count.json", $options),
      CURLOPT_POST => TRUE,
      CURLOPT_HTTPHEADER => array(),
    )));
    return $count[0];
  }
}
